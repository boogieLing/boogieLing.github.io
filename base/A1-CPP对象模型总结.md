# 对象模型总结

好文：https://www.zhihu.com/column/c_1277937360727257088

## OO和OB

OO：Object-Oriented 面向对象设计，即向多态和泛型靠拢，弹性大于OB

OB：Object-Based 基于对象设计，即只封装而不多态，效率大于OO

---

## 对象模型

1. 简单对象模型，class内全是指针，指向对应的member
2. 表格驱动模型，class内一个函数表指针，一个数据指针，指向对应的member。
3. C++对应模型，class内只有**虚表指针vptr和自身数据**，其他成员处于 text segment。

---

## 指针语义

“指向不同类型之各指针”之间的差异，既不在其指针表示法不同，也不再其内容不同，而是在其所寻址出来的object类型不同。也就是说，**“指针类型”会教导编译器如何解释某个特定地址中内存内容及其大小，以及与某些数据（函数）相匹配。**

所以一个void *指针只能持有一个地址，而不能通过它操作所指的object。

**转换（cast）其实是一种编译器指令。大部分情况下它都不改变一个指针所含的真正地址，它影响“被指出内存的大小及其内容”的解释方式。**

---

## 多态只存在于pointer/reference

A：这两者不会引发任何 **”内存中与类型相关的内存委托”**，这两者只需要改变 **所指向的内存大小** 和 **解释方式**，就可以实现多态。

而一个明确的obj实例就不行，因为其内存布局和类型早已在编译期确定，只能被静态决议。

object有可能引起”切割“。

---

## 构造顺序

1. 静态成员，**按照类外成员初始化顺序，而不是声明顺序**，而且初始化场所不在class内
2. 父类构造
   1. 虚拟base
   2. 普通base
3. 非静态成员构造，**按照声明顺序，而不是列表初始化顺序**
4. 自身构造

---

## 构造扩展

构造函数内可能内含大量的隐藏码，因为编译器会扩张每一个构造函数

1. 所有virtual base class的构造函数必须被调用，**从左到右，从深到浅**
   1. 如果virtual base class出现在member initialization list中，应该要进行参数传递。
   2. 每一个virtual base class subobject的偏移位置必须在**执行期可被存取**（不管是什么策略）
   3. 如果**class object是最底层的class**，其构造函数可能会被调用。
2. 所有上一层的base class构造函数必须被调用，以base class的声明顺序为顺序
   1. 如果base class出现在member initialization list中，应该要进行参数传递。
   2. 如果base class是多重继承下的第二或是后继base class，那么**this指针必须有所调整。**
3. 记录在member initialization list中的data members初始化操作会被放进构造函数体内，**并以member的声明顺序为顺序**
4. 如果有一个member没有出现在list中，但他有一个默认构造，那么该**默认构造函数被安插进构造函数体内，并被调用**
5. 如果class object有虚函数表指针，那么必须被设定初值，**指向适当的虚函数表**

---

## 默认构造函数

默认构造函数不需要也不允许设定返回值的原因是：**编译器规定并强制设定构造函数返回值类型为 Type *，并返回this指针**。

### Schwarz Error

单一参数的constructor被当作一个conversion运算符的错误

解决：constructor前加上 **explicit** 关键字

---

### implicit nontrivial default  constructor

只有四种情况会造成 **“编译器必须为为未声明constructor的classes合成一个nontrivial  default constructor”**

1. class有一个成员obj，该obj有一个default constructor

2. class继承而来，而其父亲有default constructor

3. class带有一个或以上的virtual function，目的：**为vptr设定初值，放置适当的virtual table地址**

4. class是virtual 继承而来，目的：**产生并设定__vbcX指针，使得能正确找到virtual父亲的位置**
   补充：

   ```cpp
   //可能的编译器转变操作
   void foo(const A *pa) {
   	pa->__vbcX->i=1024;
   }
   ```

这种被合成出来的constructor只能满足编译器（而非程序）的需要。
而且只有base class obj 和 member class obj会被正确初始化。

这四种情况之外的情况下，我们说他只拥有 **”隐式无用的默认构造函数”**，它们实际上也不会被合成出来。

---

### 多重虚拟继承

在多重虚拟继承链中，**默认构造函数会被增加一个判断，来确保只有链中末端的class能构造virtual base class**

```cpp
A* A::A(const A *this, bool __most_derived) {
    if (__most_derived != false) {
        this->Vbase::Vbase() ;
    }
    this->Base1::Base1(false) ;
    //...
    return this ;
}
```

---

### 与数组的配合

首先，**经由一个指针来启动构造函数，将无法（不被允许）存取默认参数值**

而对于一个对象数组的初始化，编译器会生成一个vec_new()来处理，原型是<code> vec_new(&a_array, sizeof(A), 10, &A::A, 0) ;</code>

需要传入一个构造函数的函数指针，但是**经由指针又无法存取默认参数值。**

**对于对象数组的new，使用vec_new(void *arr, size_t elem_size, int elem_count,...)**

其中arr表示构造的数组起始地址，如果是0，就代表在heap上配置一个新数组。而对于**没有构造函数或者是first class**的对象数组就没有必要调用该函数，因为这种情况下new[ ]和delete[ ]只需要获得内存和释放内存就行了。

**解决：**

再产生一个内部的 **stub constructor**，没有参数，在其体内调用由程序员提供的默认构造函数，并将默认参数值显式地指定。

像这样

```cpp
A::A()
{
    A(1024, 128) ;
}
```

**编译器少有的违反了一个明显的语言规则**：class如今支持了两个没有带参数的默认构造函数。

当然，只有当对象数组真正被产生出来的时候，stub实例才会被产生以及调用，**这一切的行为编译器有责任进行控制。**

所以这种方式new出一个对象数组并不是好主意，**正确方法应该使用 operatornew() 和 placement new[]**，使得自由存储区构建过程非透明化，但是**此方法的缺陷是所占领内存的生命周期和对象的生命周期不同步（对象生命周期要落后）**，在“内存紧张”的时候有可能造成“践踏”，作为弥补可以对应地预设malloc_handler以RTTI的方式临时释放内存。

---

## 拷贝构造函数

和构造函数类似，分为 trivial(无用的) 和 nontrivial，**只有nontrivial的构造函数才会被真正合成并使用**

而对于拷贝构造，是否trivial的标准在于 **class是否展示出所谓的“bitwise copy semantics”**

### bitwise copy

逐比特位拷贝语义，顾名思义，当有可能的时候会发生类似“整体字节搬移”的行为。比如Plain IO'data，而且内部成员都是**first class**的时候，大概率会发生bitwise copy。

**不展现bitwise copy的情况**

1. class内含一个member obj，而该obj有一个拷贝构造（不管是被设计者显式声明还是被编译器合成的nontrivial）
2. class继承自一个base class，而后者有一个拷贝构造
3. class声明了一个或多个virtual function
4. class派生自一个继承串链，其中有一个或多个virtual base class

---

### member wise copy

上面所述中的前两种情况，不会发生bitwise cooy，所以编译器会合成一个有用的隐式拷贝构造函数。

而合成出来的函数，就是以member wise的方式来递归拷贝，也就是逐member复制。

**不过这里并不是拥有副本，而是共同拥有**

所以可能会发生内存泄漏的问题。

---

### 其他情况

其余两种情况的目的

其实都是设定vptr指针的正确指向、维护“位置的完整性”、重新安排virtual base class的位置。

---

### 是否需要显式定义

bitwise非常快速，对于**纯内置类型数据（Plain IO'data）**构成的class来说非常安全，这种情况下我们就不要定义拷贝构造，让编译器施行bitwise就可以提高效率。

如果拷贝构造函数比较复杂，而且涉及内存管理、大量自定义成员移动、**预见了编译器会安插额外的内部member**的场景，就必须显式提供一个拷贝构造。

**但是，编译器对显式拷贝构造施行NRV优化之后，速度会碾压bitwise**

---

## 使用member initialization

三种情况**必须使用！**

1. 初始化一个引用成员变量
2. 初始化一个const 成员变量
3. 调用一个base class的构造函数，而且该构造需要一组参数

推荐使用：当内部存在一个类成员变量，那么使用list来初始化的话**不会产生额外的tmp**。

总结：编译器会对initialization list一一处理并重新排序，以反映出members的声明顺序。它会安插一些代码到constructor体内，并置于任何explicit user code之前。

---

## 对象成员的效率

在涉及计算的情况下，效率较差的CC编译器会把每一个局部变量的地址都放进一个单独寄存器，然后再在另外的寄存器中完成运算。

而且NCC编译器，在变量加载（load）阶段就会直接计算出地址，运算会直接在寄存器中完成。

**单一继承不会影响效率，因为data members的存储位置的offset在编译期就能得到，跟普通变量一样**

对于派生自虚拟继承链的Obj，如果存取virtual base class的data member，那么效率会受到“间接的__vbc指针”的影响，并且会抑制编译器的优化能力。

---

## Member指针

对data member取地址，**得到的是在class中的偏移值**

Q：如何区分一个”没有指向任何data member“的指针，和一个指向”第一个member“的指针？

A：每一个真正的member offset的值都会被加上1，所以”没有任何指向“就是0，”指向第一个“就是1。在使用的时候需要减掉1 。

注意：

data member的指针类型应该是

```cpp
int className::* 
```

而static data member的指针类型应该是

```cpp
int *
```

则会取出该member在内存中的真正地址。

### 效率

只讨论优化之后的效率

通过实例存取、指针存取、单一继承（任意层数）存取，效率都是一样的。

而对于 **虚拟继承**，每多一层都会加入额外消耗。

**虚拟继承会妨碍优化的有效性**，因为存取模式会发生改变

```cpp
int A::* pa = &A::a ;
A t1 ;
*(&t1 + (pa-1) )=1024//正常情况
*(&t1->__vbcBASE + (pa-1))=1024//单层虚拟继承
```

额外的间接性会降低 ”把所有的处理都搬移到寄存器中执行“ 的优化能力。

---

## 非静态成员函数

C++的设计准则之一：非静态成员函数至少必须和一般的nonmember function有相同的效率

1. 改写函数的原型（signature），以安插一个额外参数到function中，**用以提供一个存储管道（this指针）**
2. 将每一个"对非静态数据成员"的存取，**改为经由this指针来存取**
3. 将member function重新写成一个外部函数。函数名经过 **mangling**处理，成为一个独一无二的语汇。

```cpp
A a ;
a.foo(1024) ;
void foo(int a) {
    val = a ;
}//原状态 void A::foo(int);
//1, void A::foo(const A *const, int);
/*2,改变存取操作
void foo(const A *const this,int a) {
    this->val = a ;
}
*/
//3,name mangling
foo__7AFi(&a, 1024);
```

---

## 虚拟成员函数

虚表构建：https://zhuanlan.zhihu.com/p/190169823

如果foo()是一个虚拟成员函数

那么a->foo():

将会被内部转化为

<code>(* a->vptr[1])(a) ;</code>

**注意，vptr也有可能被mangling，因为一个class里面可能存在多个vptr**

虚函数表可以在编译器获知。程序执行时表格的大小和内容都不会改变，**其构建和存取皆可以由编译器完全掌控。**

编译期完成：

1. 构建一个虚函数表，里面放着虚函数的内存地址
2. 为了找到该表格，每一个class obj被安插了一个由编译器内部产生的指针，指向该表格
3. 为了找到函数地址，每一个虚函数都被**指派（编译期完成）**了一个表格索引值

执行期运行：

1. 决议出激活者的类型
2. 决议出激活哪个虚函数
3. 在特定的虚函数表slot中激活虚函数



如果foo()里面还调用一个goo()，goo()也是虚函数

那么goo()在foo()之中的调用操作将会被转换

```c++
void foo() 
{
	//goo();
    (* this->vptr[2])(this) ;
}
```

容易发现，此时的this能被确定，**因为foo()已经由虚拟机之而决议妥当！**，所以显式地静态调用A实例会比较有效率，并因此压制由于虚拟机制而产生的不必要的重复调用操作。

```cpp
void foo() 
{
	//this->goo();
    A::goo();//这样就够了
}
```

**当不触发多态的时候，编译器会以普通函数的方式来决议**

```cpp
A *a = &test ;
//a->foo() ; 原本的调用
//(* a->vptr[1])(a) ; 正确，但没必要
foo__7AFv(a) ;
```

这样操作的意义是，既然被当成普通函数对待，**而对于inline的成员函数，编译器会尝试在原地扩展开来**，因而能提供极大的效率利益。

---

### cfront兼容模式

在CC和NCC的cfront兼容模式下，还额外增加了一层 **delta-offset模型** 。

```cpp
ptr->virt_func() ;
//转换
(* ptr->__vptr[index].addr)(ptr + ptr->__vptr[index].delta);//调整this指针
```

优点：

在这种实现技术下，不论是单一继承还是多重继承，只要是虚拟调用操作，就会消耗相同的成本

---

### 未解决的问题

在多重继承下，对于第二个以及后继的base class，**必须在执行期调整this指针**，到现在这种需求仍然找不到较好的解决方案。

**thunk技术**

它允许虚函数表中的槽能 **继续内含一个简单的指针**，因此能在槽内直接调整传入的this的偏移值。

但是thunk技术只有以汇编代码完成才有效率，所以需要一个有效率的thunk编译器。

**现常用手段**

在多重继承下，继续内含n-1个额外的虚表，并且把vptr处以name manglig，主要的虚表与最左端的base**共享**，之后的每个base使用一个虚表。

**由于执行期链接器，符号名称的链接可能变得非常缓慢，每一毫秒只能处理一个符号名称**

**各家编译器的选择**

场景：多重继承，第一base和后续base都有相同的foo()，但是返回值不一样，而且需要调整this的偏移值

sun编译器：提供一个所谓的split function，用相同的算法产生两个函数，其中第二个返回之前为指针加上必要的offset，这样后续base调用的实际上是另一个函数，而不是被覆盖的函数。
**不仅如此，此策略会给函数产生多个进入点，这样就不需要需要的thunk了**

IBM编译器：thunk的狂热粉丝

msvc：用所谓的 **address points** 来取代thunk，所有调用方式都能直接获得“引入该virtual function的class”的地址！

### 虚函数准则

1. 倾向于使用模板方法使接口非虚拟化。
2. 优先将基类虚函数设为私有。
3. 仅当派生类需要调用虚函数的基本实现时，才使虚函数protected
4. **基类析构函数应该是public 和virtual，或者protected 和nonvirtual。**
5. 在极少数情况下，例如策略类，为方便起见，该类用作基类，而不是多态行为。建议对那些析构函数进行保护和非虚拟化。这里的目的是防止使用者直接销毁基类对象。

对于基类Base，调用代码可能会尝试通过指向Base的指针销毁派生对象，例如在使用unique_ptr \<Base\>时。如果Base的析构函数是公共的和非虚拟的（可能是隐式生成的？），则可能会意外地在实际上指向派生对象的指针上调用它，

在这种情况下，尝试删除的行为是不确定的。这种情况导致较早的编码标准对所有基类析构函数都必须是虚拟的提出了全面的要求。相反，规则应该是当且仅当基类析构函数是公共的时，才将它们虚函数化。

**但是，用户声明的析构函数会抑制生成移动操作，因此要支持移动操作**，您需要添加：

```cpp
Testable(Testable&&) = default; 
Testable& operator=(Testable&&) = default;
```

**声明移动操作将禁用复制操作，**并且您还需要：

```cpp
Testable(const Testable&) = default;
Testable& operator=(const Testable&) = default;
```



---

## 纯虚函数

虚函数存放在虚函数表中，但是纯虚函数在虚函数表中对应的位置上是一个**pure_virtual_called()函数实例**，他扮演该位置的空间保卫者的角色，如果被调用就会触发**执行期异常处理**，除非该纯虚函数被后代实现，该位置才会被覆盖为普通的虚函数。

**纯虚函数只能被静态地调用，不能经由虚拟机制调用**

在父类中纯虚函数是否实现取决于设计者，但**每一个纯虚析构函数都一定要定义实现！**

因为每一个继承的子类的析构函数会被扩张，**将以静态调用的方式调用每一个上层base class的析构函数**。
因此只要缺乏任何一个base class 的析构函数都会导致**链接失败**。

---

## inline函数

一个inline 函数实体，**在整个class声明未被完全看见之前，是不会被评估求值的。**

但Argument list中的名称还是会在它们第一次遭遇的时候被适当地决议完成。因此在extern和nested type names之间的非直觉绑定操作还是会发生。

处理一个inline的两个阶段

1. 分析函数定义，以决定函数的 **"intrinsic inline ability"**（本质的inline能力）
   如果函数因其复杂度，或者其他原因被判断不可成为inline，可能会被转为一个static函数，并在“被编译模块”内产生对应的函数定义。
   在一个支持模块个别编译的环境中，**链接器会将被产生出来的重复东西清理掉**
   **Unix系统的strip命令可以达到此目的**
2. 真正的inline函数在调用处执行扩展操作。
   **这会带来参数的求值操作以及临时性对象的管理**

**形参管理**

```cpp
inline int min(int i, int j) {
	return i < j ? i : j ;
}
```

三种调用

```cpp
int ans ;
int val1 = 1024 ;
int val2 = 128 ;
//ans = min(val1, val2) ;
ans = val1<val2 ? val1: val2 ;
//ans = min(1024, 128) ;
ans = 128 //能被直接评估求值
//ans = min(foo(), goo()+1) ;
int __temp1;
int __temp2 ;
ans = (__temp1=foo()), (__temp2=goo()+1),
	  __temp1<__temp2 ? __temp1: __temp2 ;
//目的是防止重复求值
```

**局部变量外移**

```c++
inline int min(int i, int j) {
    int ans = i < j ? i : j ;
	return ans ;
}
```

inline被扩展开来之后，为了维护其局部变量

1. 需要外移
2. 需要一个独一无二的名称，mangling
3. 如果是以分离的式子被扩展多次，只需要一组变量
4. 如果是以单一表达式被扩展多次，会导致大量的临时性对象！

```cpp
//int ans = min(val1, val2) + min(foo(), goo()+1) ;
//为局部变量服务
int __min__lv__minval__00 ;
int __min__lv__minval__01 ;

//防止重复求值的副作用
int __temp1 ;
int __temp2 ;
ans = 
    ((__min__lv__minval__00 = 
     val1<val2? val1: val2), __min__lv__minval__00)
    +
    (( (__temp1=foo()), (__temp2=goo()+1),
	  __temp1<__temp2 ? __temp1: __temp2), 			__min__lv__minval__01)
```

**这会在调用出产生出大量的额外变量**

所以如果一个inline函数被调用太多次，会产生大量的扩展码，使程序大小暴涨。

---

## 静态成员函数

和非静态成员函数相比，**最大的区别就是没有this指针**，他与一个普通函数没有太大的差别（需要通过class调用，但与普通函数一样都不需要经由实例调用）。

由于没有this指针的传入，导致了以下的限制

1. 不能直接存取类内非静态成员
2. 不能被声明为 virtual, volatile

如果取他的地址，会得到内存中的地址，也就是真正地址

**意想不到的好处：成为一个callback函数，得以将C++和C-based X windows系统结合，也可以成功应用到线程函数身上。**

---

## Member function指针

取一个非静态非虚成员函数的地址，得到的就是他在内存中的真正地址。**然而这个值是不完全的。**

他需要被绑定于某个class obj的地址上，才能通过obj调用函数。

<code> int (A:: *pmf)() = &A::foo ;</code>

调用：

<code>(a.*pmf)() ;</code>

这些操作会被编译器优化为

<code>(pmf)(&a) ;</code>

与普通函数指针不一样的地方在于他有一个**this指针**的保留段（A::），**这也是“这个地址值是不完全”的原因，他需要传入this指针来使用。**

### 虚函数指针

而对一个虚函数取地址，得到的是他在虚函数表中的偏移值，**其地址在编译时期是未知的（可能发生运行期多态）**

虚函数寻找原则

1. 我不需要知道调用其的ptr的真正类型，我只知道经由ptr可以存取到该对象的虚函数表
2. 我不知道虚函数表中调用的是谁的实例，可能是父亲的也有可能是自身的，**但我知道要调用的函数在虚函数表中的slot的位置**

问题是：**对虚函数取地址，对非静态非虚函数取地址，函数指针的形式都是相同的。**

我们该如何以一种形式决议出两种调用？

PS：通过虚函数指针调用时的内部转化<code> (* ptr->vptr[(int) pmf])(ptr)</code>

**cfront2.0非正式版的解决**

```cpp
(((int)pmf) & ~127)
	?
    （* pmf）(ptr)
    :
	(* ptr->vptr[(int) pmf])(ptr) ;
```

很明显，这种形式下最多只能有128个虚函数，但是这却是可行的。

但是在多重继承下，这种形式没有办法调整this指针的偏移值，所以需要更一般的实现模式、

**有效一般的解决**

每个member function指针都将成为一个结构体以使用

```cpp
struct __mptr {
    int delta ;
    int index ;
    union {
        ptrtofunc faddr ;
        int v_offset ;
    }
}
```

delta表示this指针需要的偏移值

v_offset放的是一个虚拟继承或是多重继承的第二及其后继的base class的vptr的位置。

在此模型之下，通过函数指针的调用操作会变成

```cpp
(pA.*pmf)(pB) ;
(pmf.index < 0)
	?
    (*pmf.addr)(&pA + pmf.delta, pB)
    :
	(* pA.vptr[pmf.index].faddr)(&pA + pA.vptr[pmf.index].delta, pB);
```

缺点

1. 所有调用都会为此付出代价
2. 有可能产生一个临时性的__mptr对象
3. 和C的兼容性进一步降低

msvc把这项检查拿掉，并导入一个他所谓的vcall thunk，这样faddr被指定的要不就是函数地址，要不就是thunk地址，thunk会负责选出并调用相关虚函数表的slot。

---

## Global

在C中，global被视为一个“临时性的定义”。一个“临时性的定义”可以在程序中发生多次，**而多个实例最终会被链接器折叠起来，只留下一个单独实例**，被放在 data segment 的.Bss段（Block started by symbol）。

注意，C的global不会自动设定初值。

**C++没有，也并不支持所谓的“临时性定义”**（因为class存在隐式构造行为）。因此，global在C++中被视为完全定义（它会阻止第二个或更多定义）。C和C++的一个差异就在于，.Bss段在C++中相对地不重要。
**C++的所有全局对象都被以“初始化过的数据”来对待**，所有未初始化的都会被处以**零初始化**，但要到程序启动时才会实施。

### 局部静态变量

保持了怎么样的语义？

1. 局部变量的构造函数只能施行一次。
2. 局部变量的析构函数只能施行一次。

旧策略：无条件地在程序起始时构造出对象，即使他们所在的函数从来未被调用。

**而现在的C++ standard已经强制要求：只有函数被调用的时候才构造出对应的静态对象。**

解决方案：

**在全局处产生一个保护对象，作为戒护之用**，并处以零初始化。

当第一次进入函数时，评估临时对象为false(临时对象指向0)，于是施行构造函数，**并将构造成功后的对象地址取出，由保护对象掌控。**

后续进入函数，如果保护对象不为空，说明是后续进入，什么都不做。析构函数也处以类似的手法。

---

##  delete[ ]的cookie

Q：为什么delete [ ]不需要指定size？/ new[size]中的size存放在哪？

A：总所周知，new[size]内部实际上调用的是vec_new()，**而size的存放使用了小甜饼(cookie)技术，即在每块new出来的位置之前配置一个额外的cookie，元素个数就在此cookie当中。**

**在vec_new()中，extern int \_\_insert\_new\_array()用于放置cookie，extern int \_\_remove\_old\_array()用来删除cookie。**

而在msvc中，new[ ]一块内存会有48字节的额外头部开销，而且头部会进行边界处理，使得该内存对于程序员来说是透明的（无法查看，就像不存在一样）。

```pascal
90 01 00 00 	(分配的内存的大小，也就是说分配的内存的大小是放在指针所指向地址的前4个字)   
01 00 00 00     (都为1)
2D 00 00 00	 	(每个内存块都不同，且递增，msvc中是分配的内存块的序号)
FD FD FD FD     (表示分配内存的开始)
CD CD CD CD
  ...           (CD，指针指向的实际分配的内存块)
CD CD CD CD
FD FD FD FD     (表示分配内存的结束）
```

进一步：为什么free()不需要指定size，也可以释放一整块空间。

A：delete[ ]实际上做了两件事，依次调用元素的析构函数、释放所占领的空间。而前者由编译器保证，要使用到cookie；但是对于后者，**操作系统内部有内存申请情况的记录**（每个申请内存段的首地址，长度，etc..)，所以不需要获取size也可以正常释放。

---

## 执行期语义

### 对象的构造和析构尽量相近

C++的设计原则之一：析构函数必须被放在每一个离开点，因此编译器要对其进行分析。最后程序中所有有可能离开的位置都会被安插进析构函数，导致大小暴涨。

所以把对象的构造和析构尽量集中，可以减少分析的区域，减少安插的析构函数。

### munch策略

目的是让运行期编译器接管对象的行为更具有移植性

1. 为每一个需要静态初始化的文件产生一个_sti()函数，内含必要的构造函数调用操作或内联扩展。
2. 类似地产生一个_std()函数，内含所有必要的析构函数调用操作。
3. 提供一组runtime library"munch"函数：一个_main()函数用来调用所有sti()函数，一个exit()函数用来调用所有的std函数
4. 在程序中安插_main()的调用操作，作为main()函数的第一个指令。

最后一个需要解决的问题是：**如何收集一个程序中的所有sti()和std()函数**

1. nm命令+munch程序，**nm会倾印出所有object file的符号表格项目。**一个可执行文件是由.o文件产生的，nm将会施行与可执行文件身上。其输出会直接输入munch程序之中，munch程序会分析符号表格中的名词，搜寻需要的函数，**然后把函数名称加到一个跳离表格**。**最后CC命令会被重新激活！对这个跳离表格的内容加以编译，再将整个可执行文件重新链接**
2. patch munch程序，检验所有可执行文件，**找出那些“有着__link nodes”**并内含一个指针，指向sti()函数的文件，把他们都串连在一起。把链表的根源设为一个全局性的__head object，执行期只要通过这个head走访一遍就知道需要调用什么函数了。

---

## 临时对象的拖累

为了规避重复的评估求值等情况

C++会产生大量的临时对象，造成不必要的copy constructor和额外的内存开销

比如：

```cpp
void foo(digit *a, const digit *b, const digit *c, int N) {
    for (int i=0 ; i<N ; ++i) {
        a[i] = b[i]+c[i] - b[i]*c[i] ;
    }
}
```

假设digit类的涉及到的运算符都被重载妥当，那么上面的循环中每次迭代都会产生多达五个的临时对象。

1. 一个临时对象，b[i]+c[i]
2. 一个临时对象，b[i]*c[i]
3. 两个临时对象，用于计算b[i]+c[i] - b[i]*c[i]
4. 一个临时对象，保存b[i]+c[i] - b[i]*c[i]的结果

现行的大部分编译系统能明显判断出内建类型的局部变量，但是对于class类型的局部变量就行不通了

**这是C++ back-ends的限制，很普遍**

效率降低的原因是 **程序中存在大量的堆栈存取操作**，可以通过反聚合的技术将个别的members放到寄存器中，就能有效缩短时间。

这种手段大有可为，可能会成为以后编译器的优化方向。

---

## 模板

前提：如果希望某个结构只有一个实例被产生出来（普通的static data就是这种作用），那么请千万不要使用模板。

设计哲学：**Lazy expression 懒惰表达**

对于由模板而来的成员，包括类中的数据成员、函数成员、类指针等等，都遵循上述设计哲学。

就算模板类中存在static data，在你实例化一个明确类型的类之前，该static data都不可用，**即使static data不需要经由实例去存取**

如果定义了一个实例化的模板类指针，但并不让他指向任何实例化的对象。**那么他在编译期和运行期将无事可做**，基于懒惰表达的哲学以及C++中的指针语义，指针只是地址拥有者+类型决议者，它本身不是一个obj，**编译器不需要知道它的布局和数据**，既然如此也就没必要实例化出一个真正的obj ；

**但是定义一个实例化的模板类引用，真的会实例出一个obj**，因为引用不可能为空。

对于成员函数，Lazy被贯彻得更加彻底，**只有在成员函数被使用的时候，C++ standard才要求他们被实例化（**虽然目前的编译器并不精确遵循该要求）。

之所以由使用者来主导”实例化“规则，有两个原因

1. 空间和时间的考虑，如果class中有100个成员函数，但是程序只针对某个类型使用其中两个，针对另一个类型使用其中五个，那么其他的193个函数都实例化的话将会花费大量的时间和空间。
2. 尚未实现的机能，并不是一个模板实例化的所有类型一定能完整支持一组成员函数所需要的所有运算符。相比于程序员，编译器更难发现这些”不能支持“的错误，这有可能造成编译期的crash 。

### **模板函数实例化**

大致设计：

1. 编译的时候，把需要实例化的函数”放置“于实例化处的文件中。
2. 链接的时候，编译器会被一些辅助工具重新激活（比如nm命令）。模板函数实例可能被放在这一文件中、别的文件中或是一个分离的存储位置。

三个问题：

1. 编译器如何找出函数定义？
   1. **包含template program text file，就好像他是一个header文件一样。**
   2. 要求一个文件命名规则，以能区分普通函数和模板函数
2. 编译器如何能够只实例化用到的成员函数？
   1. 根本忽略这一项要求，Borland就是这样处理的。
   2. **模拟链接操作**，检测查看哪一个函数真正需要，然后为他们产生实例。
3. 编译器如何阻止成员函数在多个.o文件中都被实例化呢？
   1. 产生多个实例，然后由链接器提供支持，只留下其中一个（Unix系统的strip命令），其他忽略
   2. **由使用者来引导”模拟链接阶段“的实例化策略，决定哪些策略才是所需求的。**

**常用的自动实例化机制**

1. 一个程序的原始码被编译，最初并不会产生任何模板实例化行为。然而，把相关信息产生于object files之中
2. **当object files被链接的时候，会有prelinker程序被执行。**它会检测object files，寻找模板实例的相互参考以及对应的含义。
3. 对于每一个”参考到模板实例“而”该实例却没有定义“的情况，prelinker程序**将该文件视为与另一个实例化等同**。这些会被注册到prelinker产生出来的.ii文件之中。
4. **prelinker重新激活编译器，重新编译每一个”.ii文件层改变过“的文件。**这个过程不断重复，知道所有必要的实例化操作都已经完成。
5. 把所有object files链接成一个可执行文件 (main-inker)。

---

## Exception Handling

C++的exception handling由三个主要的语汇组件构成

1. 一个throw子句。它在程序某处发出一个exception，被抛出的信息可以是内建类型，也可以是自定义类型。
2. 一个或者多个catch子句，每一个catch子句都是一个处理者，它用来表示说：这个子句准备处理某种类型的异常抛出，并且在**封闭的大括号区段**中提供实际的处理程序
3. 一个try区段。它被围绕以一系列的叙述句，这些叙述句有可能是引发异常的源头。

**对于每一个被抛出的异常，编译器都必须产生一个类型描述器！（RTTI就是支持EH之后的副产品）**

**每个catch子句被写下后，编译器也需要为其产生一个类型描述器**

当一个exception被抛出，控制器会从函数调用中被释放，并寻找一个吻合的catch子句。

如果没有吻合者，那么默认的处理例程**terminate()**会被调用。

当控制权被放弃之后，堆栈中的每一个函数调用也就被推离。这就是**unwinding the stack**。每个函数被推离堆栈之前，函数的局部变量的析构函数会被调用。这个过程可能涉及**对共享内存加锁、处理释放的内存、滞空**等等额外操作。

**区段划分**

有了EH之后，一个函数可以被想象成几个区域的组成

1. try区段之外的区域，而且没有 **积极的局部变量**（类模板指针就是消极的，内置变量也是消极的）
2. try区段之外的区域，但是有一个 积极局部变量 需要析构，这种区段会被大量划分
3. try区段之内的区域。

**发生时的处理**

1. 检验throw操作的函数
2. 决定throw操作是否在try区段之内
   1. 是，编译系统把exception的类型描述器和每一个catch子句比较
      1. 吻合，流程控制从编译系统交给catch子句
   2. 其他情况，**系统必须摧毁所有涉及到的积极局部变量，进行堆栈unwind**，进行到程序堆栈的下一个函数去。

**catch子句对于expection object的任何改变都要遵循局部性原则。**

对于EH机制，还有更多的规则可以探讨，但是实在太多了。

---

## RTTI

RTTI体现在方方面面，受其帮助最大的应该是多态机制。

它的核心是**类型描述器**，除此以外也并无更多了，只是应用广泛。

它提供了Type-Safe Donwcast, Type-Safe Dynamic Cast, Typeid运算符等等。

在此附带一段能**辅助巡航于多态机制**的代码

```cpp
#include <bits/stdc++.h>
using namespace std ;

class A
{
public:
	A() {
		this->val = 10 ;
	}
	~A() {

	}
	virtual void foo1() {
		printf("A foo1\n");
	}
	virtual void foo2() {
		printf("A foo2\n");
	}
	int val ;
};
class B:public A
{
public:
	B() {
		this->val = 20 ;
	}
	~B() {
	}
	void foo1() {
		printf("B foo1\n");
	}
	void foo2() {
		printf("B foo2\n");
	}
	int val ;
};

typedef void (*PNC)() ;
signed main(int argc, char const *argv[])
{
	A a ;
	B b ;

	//void *p = (void *)&b ;
	A *t1 = &b ;
	void *p = (void *)t1 ;
	//get vptr
	int **vtbl = (int **)*(int **)p ;
	printf("vtbl: %p\n", vtbl);
	//get type_info
	printf("type_info[-1] %p\n", vtbl[-1]);
	//cout<<((type_info *)vtbl[-1])->name() ;
	printf("type_info: %s\n", ((type_info *)vtbl[-1])->name());
	
	void (A::*pf)() = &A::foo1 ;
	PNC pmf = (PNC)(vtbl[1]) ;
	//注意此处没有为this指针预留区段
    //vtbl[0]的调用实例静态决议，没有发生多态，多态发生于A *t1 = &b ;
	(a.*pf)() ;
	pmf() ;

	p += sizeof(int **) ;
	void *tmp = p+sizeof(int) ;
	printf("A val %d\n", *(int *)p) ;
	printf("B val %d\n", *(int *)tmp) ;
	
	return 0;
}
```

「除单元测试外，不要使用 dynamic_cast，不要涉及RTTI，如果你需要在运行时确定类型信息，**说明设计有缺陷。**」









